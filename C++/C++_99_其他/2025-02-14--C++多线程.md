---
category: Cpp
date: 2025-02-14 09:00:00 +0800
layout: post
title: C++多线程
tag: CppOthers
---
## 摘要

+ 学习并整理C++中关于多线程的知识。
  + 一方面用于巩固知识，更加深入理解多线程，建立良好的体系结构；
  + 另一方面用于当前的面试，学到的东西能够说出来。

<!--more-->

## C++多线程基础概念

### 基础概念

+ 线程，是程序中的轻量级执行单元，允许程序同时执行多个任务。
  + 线程是程序执行中的单一顺序控制流，多个线程可以在同一个进程中独立运行
  + 线程共享进程的地址空间，文件描述符，堆和全局变量等资源，但是每个线程有自己的栈，寄存器和程序计数器。
+ 多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。
+ 一般情况下，两种类型的多任务处理：**基于进程** 和 **基于线程**
  + 基于进程的多任务处理是程序的并发执行。
  + 基于线程的多任务处理是同一程序的片段的并发执行。
+ C++多线程编程涉及在一个程序中创建和管理多个**并发执行**的线程。
+ 并发(Concurrency)和并行(Parallelism)
  + 并发：多个任务在时间片段内交替执行，表现出同时进行的效果
  + 并行：多个任务在多个处理器或处理器核上同时执行
+ C++11及以后的标准提供了多线程支持，核心组件包括：
  + std::thread， 用于创建和管理线程
  + std::mutex， 用于线程之间的互斥，防止多个线程同时访问共享资源
  + std::lock_guard和std::unique_lock， 用于管理锁的获取和释放
  + std::condition_variable， 用于线程间的条件变量，协调线程间的等待和通知
  + std::future和std::promise， 用于实现线程间的值传递和任务同步。

+ 进程是**系统资源分配**地最小单位，是应用程序运行地环境。
+ 线程是**任务执行**地最小单位，一般是执行某个function。
  
### 关于并发

+ 在单核CPU上，并发并不是真正的并发，而是通过时间片轮询的方式执行，使其看起来像是并发。
+ 真正的并发应该是在多核CPU上面。

### C++中多线程编程

+ 传统的C++(C++11标准之前)中并没有引入线程这个概念，在C++11发布之前，如果想要在C++中实现多线程，需要借助操作系统平台提供的API，例如Linux的<pthread.h>，或者windows下的<windows.h>；或者接触第三方库，例如Boost。
+ C++11提供了语言层面上的多线程，包含在头文件<thread>中。它解决了跨平台的问题，提供了管理线程，保护共享数据，线程间同步操作，原子操作等类。
+ C++11新标准中引入了5个头文件来支持多线程编程，如下图所示：
![C++多线程相关标准库梳理](/images/C++/C++_99_其他/C++多线程相关标准库梳理.png)

## 多进程与多线程

### 多进程并发

+ 使用多进程并发是将一个应用程序划分为多个独立的进程(每个进程只有一个线程)，这些独立的进程间可以互相通信，共同完成任务。由于操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比使用多线程更容易写出相对安全的代码。
+ 但是，这也造就了多进程并发的两个缺点：
  + 在进程间通信，无论是使用信号，套接字，还是文件，管道等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼而有之
  + 运行多个进程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。
+ 当多个进程并发完成同一个任务时，不可避免的是：操作同一个数据和进程间的相互通信，上述的两个缺点也就决定了多进程的并发并不是一个好的选择。所以就引入了多线程的并发。

### 多线程并发

+ 多线程并发指的是在同一个进程中执行多个线程。
+ 优点：
  + 线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。
+ 缺点：
  + 由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)
+ **共享数据的管理**以及**线程间的通信**，是多线程编程的两大核心。

## 共享数据的管理

+ 不同线程对共享数据进行读写时，可能会发生冲突，因此需要进行特殊地处理，例如加锁，线程间互斥等。

## 线程间的通信

## 线程管理

+ 每个应用程序至少有一个进程，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个线程。
+ 每个线程都需要一个入口函数，入口函数返回退出，该线程也会退出，主线程就是以 main 函数作为入口函数的线程。

### 启动一个线程

```cpp
do_task();
std::thread(do_task);
```
+ 这里创建std::thread传入的函数，实际上其构造函数需要的是可调用(callable)类型，只要是有函数调用类型的实例都是可以的。例如：
  + lambda表达式
```cpp
for (int i = 0; i < 4; i++)
{
    std::thread t([i]{
        std::cout << i << std::endl;
    });
    t.detach();
}
```
  + 重载了()运算符的类的实例
```cpp
class Task
{
public:
    void operator()(int i)
    {
        std::cout << i << std::endl;
    }
};

int main()
{
    for (int i = 0; i < 4; i++)
    {
        Task task;
        std::thread t(task, i);
        t.detach();
    }
}
```
+ 将函数对象传入std::thread的构造函数时，要注意一个C++的语法解析错误。向std::thread的构造函数传入的是一个临时变量，而不是命名变量就会出现语法解析错误。如下所示
```cpp
std::thread t(Task());
```
+ 这里相当于声明了一个函数t,其返回类型为 std::thread，而不是启动了一个新的线程。可以使用新的初始化语法(统一初始化列表)避免这种情况
```cpp
std::thread t{Task()};
```

### 线程的销毁

+ 当线程启动后，一定要在和线程相关联的thread销毁前，确定以何种方式等待线程执行结束。
+ C++11有两种方式来等待线程结束
  + **detach方式**。启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。
    + 调用detach标识thread对象和其表示的线程完全分离
    + 分离之后的线程是不在受约束和管制，会单独执行，直到执行完毕释放资源，可以看作是一个daemon线程。
    + 分离之后thread对象不再表示任何线程
    + 分离之后joinable() == false，即使线程还在执行。
  + **join方式**。等待启动的线程完成，才继续往下执行。
    + 只有处于活动状态线程才能调用join，可以通过joinable()函数检查；
    + joinable() == true表示当前线程是活动线程，才可以调用join()函数
    + 默认构造函数创建的对象是joinable() == false;
    + join()只能被调用一次，之后joinable()就会变为false，表示线程执行完毕。
    + 调用terminate()的线程必须是joinable() == false
    + 如果线程不调用join()函数，即使执行完毕也是一个活动线程，即joinable() == true，依然可以调用join()函数。
+ 无论在何种情况，一定在thread销毁前，调用t.join或者t.detach，来决定线程以何种方式运行。

+ 当使用join方式时，会阻塞当前代码，等待线程完成推出后，才会继续向下执行
+ 而使用detach方式则不会对当前代码造成影响，当前代码继续向下执行，创建的新线程同时并发执行。这时候需要特别注意：**创建的新线程对当前作用域的变量的使用。**创建新线程的作用域结束后，有可能线程仍然在执行，这时局部变量随着作用域的完成已经销毁，如果线程继续使用局部变量的引用或者指针，会出现意想不到的错误，并且这种错误很难排查。
+ 在以detach的方式执行线程时，要将线程访问的局部数据复制到线程的空间(使用值传递)，一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域 结束前执行结束。
+ 当然，使用join方式的话就不会出现这种问题，它会在作用域结束前完成退出。

+ **需要注意地是**
  + 线程是在 std::thread 对象被定义的时候开始执行地，而不是在调用join()函数时才执行地，调用join()函数只是阻塞等待线程结束并回收资源。
  + 分离地线程(执行detach()地线程)会在调用它地线程结束或者自己结束时自动释放资源
  + 线程会在函数运行完毕后自动释放，不推荐利用其他方法强制结束线程，可能会因资源未释放而导致内存泄漏
  + 若没有执行join()或者detach()地线程在程序结束时会引发异常。

### 异常情况下等待线程完成

+ 当决定以detach方式让线程在后台运行时，可以在创建thread的实例后立即调用detach，这样线程就会将thread的实例分离，即使出现异常thread的实例被销毁，仍然能够保证线程在后台运行。
+ 但线程以join方式运行时，需要在主线程的合适位置调用join方法，如果调用join前出现了异常，thread被销毁，线程就会被异常所终结。为了避免异常将线程终结，或者由于某些原因，例如线程访问了局部变量，就要保证线程一定要在函数退出前完成，就要保证在函数退出前调用join。
```cpp
void func()
{
    std::thread t([]{
        std::cout << "Hello C++11" << std::endl;
    });

    try 
    {
        do_something_else();
    }
    catch (...)
    {
        t.join();
        throw;
    }
    t.join();
}
```
+ 上面代码能够保证在正常或者异常的情况下，都会调用join方法，这样线程一定会在函数func退出前完成。但是使用这种方法不但代码冗长，而且会出现一些作用域的问题，并不是一个很好的解决方法。
+ 一种比较好的方法是资源获取即初始化(RAII, Resource Acquisition Is Initialization)，该方法提供一个类，在析构函数中调用join
```cpp
class thread_guard
{
    std::thread &t;
public:
    explicit thread_guard(thread& _t): t(_t)
    {

    }
    ~thread_guard()
    {
        if (t.joinable())
            t.join();
    }

    thread_guard(const thread_guard&) = delete;
    thread_guard& operator=(const thread_guard&) = delete;
};

    void func()
    {
        std::thread t([]{
            std::cout << "Hello thread" << std::endl;
        });

        thread_guard g(t);
    }
```
+ 无论是何种情况，当函数退出时，局部变量g调用其析构函数销毁，从而能够保证join一定会被调用。

### 向线程传递参数

+ 向线程调用的函数传递参数也是很简单，只需要在构造thread的实例时，依次传入即可。
```cpp
void func(int *a, int n)
{

}

int buffer[10];
std::thread t(func, buffer, 10);
t.join();
```
+ 需要注意的是，**默认的会将传递的参数以拷贝的方式复制到线程空间，即使参数的类型是引用**。例如
```cpp
void func(int a, const std::string &str);
std::thread t(func, 3, "hello");
```
+ func的第二个参数是 std::string&，而传入的是一个字符串字面量。该字面量以const char*类型传入线程空间后，在线程空间内部转换为std::string.

+ 如果在线程中使用引用来更新对象时，就需要注意了。默认的是将对象拷贝到线程空间，其引用的是拷贝的线程空间的对象，而不是初始希望改变的对象。
+ 在将对象传入线程的时候，调用std::ref / std::cref，将参数的引用传入线程，而不是一个拷贝。
  + std::ref，可以包装按引用传递地值为右值
  + std::cref，可以包装按const引用传递地值为右值

+ 也可以使用类的成员函数作为线程函数，如下所示
```cpp
class _tagNode
{
public:
    void do_some_work(int a);
};
_tagNode node;
std::thread t(&_tagNode::do_some_work, &node, 20);
```
+ 上面创建的线程会调用node.do_some_work(20)，第三个参数为成员函数的第一个参数，以此类推。

### 转移线程的所有权

+ thread是可移动(movable)的，但不可复制(copyable)的。可以通过std::move()来改变线程的所有权，灵活的决定线程在什么时候join或者detach
```cpp
std::thread t1(f1);
std::thread t3(std::move(t1));
```
+ 将线程从t1转移给t3，这时候t1就不再拥有线程的所有权，调用t1.join或者t1.detach会出现异常，要使用t3来管理线程。这就意味着thread可以作为函数的返回类型，或者作为参数传递给函数，能够更加方便地管理线程。
+ 线程地标识类型为std::thread::id，有两种方式获得线程地id
  + 通过thread地实例调用std::thread::get_id()直接获取
  + 在当前线程上调用std::this_thread::get_id()获取。

## 线程池

### 概念

+ 在一个程序中，如果我们需要多次使用线程，这就意味着需要多次的创建并销毁线程。而创建并销毁线程的过程势必会消耗内存，线程过多会带来调动的开销，进而影响缓存的局部性和整体性能。
+ 线程的创建并销毁有以下一些缺点
  + 创建太多线程，将会浪费一定的资源，有些线程未被充分使用
  + 销毁太多线程，将导致之后浪费时间再次创建它们
  + 创建线程太慢，将导致长时间的等待，性能变差
  + 销毁线程太慢，将导致其他线程资源饥饿
+ 线程池维护着多个线程，这避免了在处理短时间任务时，创建与销毁线程的代价。

## 互斥量 std::mutex

+ 在多线程编程中，需要注意以下问题
  + 线程之间地共享数据访问需要进行同步，以防止数据竞争和其他问题。可以使用互斥量，条件变量等机制进行同步。
  + 可能会发生死锁问题，即多个线程互相等待对象释放锁，导致程序无法继续执行。
  + 可能会发生竞态条件问题，即多个线程执行地顺序导致结果地不确定性。

### lock()与unlock()

+ std::mutex是C++11中最基本地互斥量，一个线程将mutex锁住时，其他地线程就不能操作mutex，直到这个线程将mutex解锁。
+ **注意**
  + 加锁和解锁地顺序必须相同
  + 不能在未获得锁地情况下对共享数据进行操作
  + 由于使用了std::mutex来控制对象资源地访问，因此可能会对程序地性能造成影响，如果需要优化程序性能，可以考虑使用无锁编程等技术。

+ 粒度一般用粗细来描述
  + 锁住地代码越少，这个锁地粒度就细，执行效率就越高
  + 锁住地代码越多，这个锁地粒度就粗，执行效率就越低。

### lock_guard

+ std::lock_guard是C++标准库中地一个模板类，用于实现资源地自动加锁和解锁。它是基于RAII(资源获取即初始化)地设计理念，能够确保在作用域结束时自动释放锁资源，避免了手动管理锁地复杂性和可能出现地错误。
+ **主要特点如下**
  + **自动加锁**：在创建std::lock_guard对象时，会立即对指定地互斥量进行加锁操作。这样可以确保在进入作用域后，互斥量已经被锁定，避免了并发访问资源地竞争条件。
  + **自动解锁**：std::lock_guard对象在作用域结束时，会自动释放互斥量。无论作用域是通过正常的流程结束，异常抛出还是使用return语句提前返回，std::lock_guard都能保证互斥量被正确解锁，避免了资源泄露和死锁地风险。
  + **适用于局部锁定**：由于std::lock_guard是通过栈上地对象实现地，因此适用于局部范围内锁定互斥量。当超出std::lock_guard对象地作用域时，互斥量会自动解锁，释放控制权。

+ 使用std::lock_guard地一般步骤如下
  + 创建一个std::lock_guard对象，传入要加锁地互斥量为参数
  + 执行需要加锁保护地代码块
  + std::lock_guard对象地作用域结束时，自动调用析构函数解锁互斥量
```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;

void thread_function()
{
    std::lock_guard<std::mutex> lock(mtx);
    std::cout << "Thread running" << std::endl;
}

int main()
{
    std::thread t1(thread_function);
    t1.join();
    std::cout << "Main thread exits!" << std::endl;

    return 0;
}
```

### unique_lock

+ std::unique_lock是C++标准库中地一个模板类，用于实现更加灵活地互斥量地加锁和解锁操作。它提供了比std::lock_guard更多地功能和灵活性。
+ std::unique_lock地主要特点如下：
  + **自动加锁和解锁**：与std::lock_guard类似，std::unique_lock在创建对象时立即对指定的互斥量进行加锁操作，确保互斥量被锁定。在对象的生命周期结束时，会自动解锁互斥量。这种自动加锁和解锁的机制避免了手动管理锁的复杂性和可能出现的错误。
  + **支持灵活地加锁和解锁**：相对于std::lock_guard地自动加锁和解锁，std::unique_lock提供了更灵活地方式。它可以在需要地时候手动加锁和解锁互斥量，允许在不同地代码块中对互斥量进行多次加锁和解锁操作。
  + **支持延迟加锁和条件变量**：std::unique_lock还支持延迟加锁地功能，可以在不立即加锁地情况下创建对象，稍后根据需要进行加锁操作。此外，它还可以与条件变量(std::condition_variable)一起使用，实现更复杂地线程同步和等待机制。
+ 使用std::unique_lock地一般步骤如下
  + 创建一个std::unique_lock对象，传入要加锁地互斥量作为参数
  + 执行需要加锁保护的代码块
  + 可选地手动调用lock()对互斥量进行加锁，或者在需要时调用unlock()手动解锁互斥量。
```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;  // 互斥量

void thread_function()
{
    std::unique_lock<std::mutex> lock(mtx);  // 加锁互斥量
    std::cout << "Thread running" << std::endl;
    // 执行需要加锁保护的代码
    lock.unlock();  // 手动解锁互斥量
    // 执行不需要加锁保护的代码
    lock.lock();  // 再次加锁互斥量
    // 执行需要加锁保护的代码
}  
// unique_lock对象的析构函数自动解锁互斥量

int main()
{
    std::thread t1(thread_function);
    t1.join();
    std::cout << "Main thread exits!" << std::endl;
    return 0;
}
```

## 条件变量 std::condition_variable

+ std::condition_variable是C++标准库地一个类，用于在多线程编程中实现线程间地条件变量和线程同步。它提供了等待和通知地机制，使得线程可以等待某个条件成立时被唤醒，或者在满足某个条件时通知其他等待地线程。
+ 它提供了以下几个函数用于等待和通知线程
  + **wait()**: 使当前线程进入等待状态，直到被其他线程通过 notify_one() 或 notify_all() 函数唤醒。该函数需要一个互斥锁作为参数，调用时会自动释放互斥锁，并在被唤醒后重新获取互斥锁。
  + **wait_for()**:  使当前线程进入等待状态，最多等待一定地时间，直到被其他线程通过nofity_one()或notify_all()函数唤醒，或者等待超时。该函数需要一个互斥锁和一个时间段作为参数，返回时有两种情况：等待超时返回 std::cv_status::timeout，被唤醒返回std::cv_status::no_timeout。
  + **wait_util()**: 使当前线程进入等待状态，直到被其他线程通过notify_one()或notify_all()函数唤醒，或者等待时间达到指定地绝对时间点。该函数需要一个互斥锁和一个绝对时间点作为参数，返回时有两种情况：时间到达返回 std::cv_status::timeout，被唤醒返回std::cv_status::no_timeout。
  + **notify_one()**: 唤醒一个等待中地线程，如果有多个线程在等待，则选择其中一个线程唤醒。
  + **notify_all()**: 唤醒所有等待中地线程，使它们从等待状态返回。
+ **主要特点如下**：
  + **等待和通知机制**： std::condition_variable 允许线程进入等待状态，直到某个条件满足时才被唤醒。线程可以调用wait()进入等待状态，并指定一个互斥量作为参数，以确保线程在等待期间互斥量被锁定。当其他线程满足条件并调用nofity_one或者nofity_all函数时，等待地线程将被唤醒并继续执行。
  + **与互斥量配合使用**：std::condition_variable需要与互斥量(std::mutex或std::unique_lock<std::mutex>)配合使用，以确保线程之间地互斥性。在等待之前，线程必须先锁定互斥量，以避免竞争条件。当条件满足时，通知其他等待地线程之前，必须再次锁定互斥量。
  + **支持超时等待**：std::condition_variable提供了带有超时参数地等待函数wait_for()和wait_util()，允许线程在等待一段时间后自动被唤醒。这对于处理超时情况或限时等待非常有用。
+ 使用std::condition_variable地一般步骤如下
  + 创建一个std::condition_variable对象
  + 创建一个互斥量对象(std::mutex或std::unique_lock<std::mutex>)
  + 在等待线程中，使用std::unique_lock锁定互斥量，并调用wait()进入等待状态
  + 在唤醒线程中，使用std::unique_lock锁定互斥量，并调用notify_one()或者notify_all()通知等待地线程。
  + 等待线程被唤醒后，继续执行相应地操作。
```cpp
#include <iostream>
#include <thread>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
bool isReady = false;

void thread_function()
{
    std::unique_lock<std::mutex> lock(mtx);
    while (!isReady)
    {
        cv.wait(lock);
    }
    std::cout << "Thread is notified" << std::endl;
}

int main()
{
    std::thread t(thread_function);

    std::this_thread::sleep_for(std::chrono::seconds(2));

    {
        std::lock_guard<std::mutex> lock(mtx)
        isReady = true;
    }
    cv.notify_one();

    t.join();

    return 0;
}
```

## 原子操作 std::atomic

+ std::mutex可以很好地解决多线程资源争夺地问题，但它每次循环都要加锁，解锁，这样固然会浪费很多地时间。
+ 在C++中，std::atomic是用来提供原子操作地类，atomic，本意为原子。原子操作是最小地且不可并行化地操作。这就意味着即使是多线程，也要像同步进行一样同步操作原子对象，从而省去了互斥量上锁，解锁地时间消耗。
+ 使用 std::atomic 可以保证数据在操作期间不被其他线程修改，这样就避免了数据竞争，使得程序在多线程并发访问时仍然能够正确执行。

## C++多线程编程地常见问题与应对策略

### 死锁与饥饿

+ 死锁和饥饿是多线程编程中常见地问题，需要特殊注意。
  + 死锁是指两个或多个线程互相等待对方释放锁地情况，导致线程无法继续执行地问题。
  + 饥饿则是指某个线程无法获得所需资源，导致该线程无法继续执行地问题。

+ 对于死锁问题：
  + 一种常见地解决方法是**避免使用多个锁**或**在使用多个锁时统一获取锁地顺序**，以避免出现环路依赖死锁地情况。
  + 另一种常见的解决方式是**使用RAII技术**，将锁地获取和释放放在同一个类中，使用智能指针管理这些类，避免手动操作锁地获取和释放，减少人为错误。

+ 对于饥饿问题需要让所有线程公平竞争资源，避免一些线程独占资源导致其他线程无法继续执行。
  + 一种常见的解决方式是使用队列等数据结构，在多个线程之间共享数据资源，让所有线程均有机会获得资源，从而避免饥饿问题地发生。

### 竞态条件和原子操作

+ 竞态条件是指多个线程同时访问和修改同一个共享资源时，导致最终结果依赖于不同线程执行顺序地情况。
+ 原子操作则指不可被中断地操作，可以保证对一个共享变量地操作是不可分割，完整地。

+ 对于竞态条件问题
  + 一种常见的解决方式是**使用锁和互斥量等同步机制来控制共享资源地访问和修改**，保证同一时间只有一个线程可以访问和修改共享资源
  + 另一种常见地解决方式是**使用原子操作**，通过CAS(Compare-and-Swap)等机制保证对共享变量地操作是原子性地，从而避免竞态条件地发生。

### 线程安全性

+ 多线程编程中线程安全性是一个非常重要的问题，指的是多个线程并发执行时，程序地行为仍然是正确地。
+ 对于线程安全性地保证，可以采用许多不同地技术手段，例如使用互斥量，条件变量，原子操作，Thread-Local Storage等技术，避免共享资源地访问冲突和数据竞争，从而保证线程安全性。
+ **需要注意的是**：
  + 线程安全并不是绝对的，为了保证线程安全性，必须深入了解程序地细节，并对可能出现地并发问题进行充分地测试和验证，从而保证多线程程序地稳定性和可靠性。