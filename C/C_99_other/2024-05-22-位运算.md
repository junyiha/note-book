---
category: C
date: 2024-05-22 09:00:00 +0800
layout: post
title: 位运算
tag: COthers
---
## 简介

+ 位运算相关笔记

## 什么是位运算？

+ 所谓位运算，就是对一个比特(bit)位进行操作。比特(bit)是一个电子元器件，8个比特构成一个字节(byte)，它已经是粒度最小的可操作单元了。一个比特(bit)位只有0和1两个取值。
+ C语言中不能直接使用二进制，位运算两边的操作符可以是十进制，八进制，十六进制，它们在内存中最终都是以二进制形式存储。
+ C语言提供了六种位运算符:
  + 运算符    &      |       ^      ~    <<   >>
  + 说明    按位与  按位或  按位异或  取反  左移  右移

## 按位与运算(&)

+ 参与 & 运算的两个位都为 1 时，结果才为 1,否则为 0。例如 1&1 为 1, 0&0 为 0, 1&0 也为 0,这和逻辑运算符 && 非常类似。

+ 常用场景：按位与运算通常用来对某些位清0
  + 取一个数中的某些指定位，保留一个数中的某些指定位
    + 例如要把n的高16位清0，保留低16位，可以进行 n&0xFFFF 运算。(0xFFFF在内存中的存储行为 0000 0000 - 0000 0000 - 1111 1111 - 1111 1111)
    + 清0。将一个单元与0进行位与运算结果为0
    + 取一个数指定位为0。例如 置X=1010 1101的高四位置0,则将X & 0xF得到 0000 1101
  + 判断奇偶性：例如一个数 &1 的结果就是取二进制最末位，这样可以判断一个整数的奇偶性，二进制的最末位为0表示偶数，为1表示奇数
    + 例如 if ((a & 1) == 0) 代替 if (a % 2 == 0)来判断a是不是偶数

## 按位或运算(|)

+ 参与 | 运算的两个二进制位有一个为1时，结果就为1，两个都为0时，结果才为0。例如 1|1 为 1, 0 | 0 为0, 1 | 0为1,这和逻辑运算中的 || 非常类似。

+ 常用场景: 按位或运算可以用来将某些位置1,或者保留某些位
  + 例如要把n的高16位置1,保留低16位，可以进行 n | 0xFFFF000运算 (0xFFFF000在内存中的存储形式为 1111 1111 - 1111 1111 - 0000 0000 - 0000 0000)

## char, int, long, float, double等在**64位**下占多少字节

+ char : 1 byte
+ char* : 8 bytes
+ short int : 2 bytes
+ int : 4 bytes
+ unsigned int : 4 bytes
+ float : 4 bytes
+ double : 8 bytes
+ **long : 8 bytes**
+ long long : 8 bytes
+ **lonunsigned long : 8 bytes**

## char, int, long, float, double等在**32位**下占多少字节

+ char : 1 byte
+ char* : 4 bytes
+ short int : 2 bytes
+ int : 4 bytes
+ unsigned int : 4 bytes
+ float : 4 bytes
+ double : 8 bytes
+ **long : 4 bytes**
+ long long : 8 bytes
+ **unsigned long : 4 bytes**

## (addr >> 8) & 0xff

+ `>>` : 右移
+ 0xff: `0000 0000 0000 0000 0000 0000 1111 1111`
+ & 0xff的目的：只取出当前低(最右面)8位，其他位补0
+ `>>`右移8位，之后 `& 0xff`，则是取出未移位前数的高8位(当前数最右面的8位)的数值
```c
char SndStr[100];
int addr;

SndStr[8] = (addr >> 8) & 0xff;  // 取高8位(取高位字节)
SndStr[9] = addr & 0xff;  // 取低8位(取低位字节)
```