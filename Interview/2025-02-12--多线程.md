---
category: Interview
date: 2025-02-12 09:00:00 +0800
layout: post
title: 多线程
tag: cpp
---
## 摘要

+ 搜集的关于多线程的面试题及答案

<!--more-->

## 线程池用到哪些线程间通讯

+ 线程池通常使用以下几种线程间通讯方式：
  + **任务队列(Task Queue)**： 线程池中的线程从任务队列中获取待执行的任务。通过将任务放入任务队列，可以实现生产者-消费者模型，在多个线程之间传递任务
  + **线程同步机制**：在多个工作线程同时处理任务时，可能需要使用互斥锁，条件变量等线程同步机制来保证数据的一致性和避免竞态条件
  + **回调函数(Callback)**：当一个任务完成后，可以通过回调函数将结果返回给调用方或者通知其他相关的模块
  + **线程间信号量(Thread Synchronization Primitives)**： 通过信号量等同步原语，可以实现多个线程之间的协调和控制
  + **共享内存(Shared Memory)**：多个线程可以通过共享内存在进行数据交换，但需要注意对共享数据的访问控制，以避免竞态条件

+ 这些通讯方式可以帮助线程池中的线程协作执行任务，并且能够有效地管理和分配工作负载。具体使用哪种通讯方式取决于应用程序的需求和设计

## linux 线程是怎么调度的 详解

在Linux系统中，线程的调度是由内核负责的，它根据线程的优先级和调度策略来确定线程的执行顺序。Linux提供了多种调度策略，包括先进先出（FIFO）、循环时间片（Round Robin）、实时（Real-time）等，每种策略都有不同的特点和适用场景。下面是关于Linux线程调度的详细解释：

### 1. 调度策略：

#### 先进先出（FIFO）调度：

- **特点**：按照线程加入队列的顺序执行，先加入队列的线程先执行，直到线程主动放弃CPU或者阻塞。
- **应用场景**：适用于不需要时间片轮转的场景，例如实时任务和需要按顺序执行的任务。

#### 循环时间片（Round Robin）调度：

- **特点**：按照时间片轮转的方式轮流执行每个线程，每个线程执行一个时间片后，被放回队列尾部等待下一次调度。
- **应用场景**：适用于多任务环境，可以公平地分配CPU时间，防止某个线程长时间占用CPU。

#### 实时（Real-time）调度：

- **特点**：按照线程的优先级执行，优先级高的线程具有更高的执行优先级，可以抢占优先级低的线程。
- **应用场景**：适用于对响应时间要求较高的实时任务，需要保证任务按时完成。

### 2. 调度器（Scheduler）：

Linux内核的调度器负责根据线程的优先级和调度策略来确定线程的执行顺序。常见的调度器包括CFS（完全公平调度器）和实时调度器（Real-time Scheduler），它们根据不同的调度算法和策略来进行线程调度。

- **CFS调度器**：CFS调度器是Linux内核默认的调度器，它通过红黑树数据结构来管理线程的优先级和调度顺序，采用最小化任务运行时间的方式来保证公平性和响应性。
- **实时调度器**：实时调度器是针对实时任务的调度器，包括FIFO调度器和RR调度器，它们按照不同的调度策略来保证实时任务的及时响应和高优先级的执行。

### 3. 调度优先级：

Linux线程的调度优先级范围通常是0到139，其中0是最高优先级，139是最低优先级。线程的优先级决定了它在调度队列中的位置和被调度的顺序，优先级高的线程会更快地获取CPU时间片。

### 4. 调度实现：

Linux的调度器是在内核中实现的，通过调度器模块和调度算法来实现线程的调度和管理。不同的调度策略和优先级会影响线程的调度顺序和CPU时间分配，可以根据实际需求选择合适的调度策略和优先级来优化系统的性能和响应性。

总的来说，Linux线程的调度是由内核负责的，根据线程的优先级和调度策略来决定线程的执行顺序和CPU时间分配。不同的调度策略和优先级适用于不同的场景，可以根据实际需求进行选择和配置。

## linux 线程调度算法 详解

在 Linux 中，线程调度算法是由内核的调度器负责实现的，它决定了在多个线程之间如何分配 CPU 时间片。Linux 内核提供了多种调度算法，常见的有 CFS（完全公平调度器）和实时调度器（Real-time Scheduler）。下面详细解释这些调度算法：

### 1. 完全公平调度器（CFS）：

CFS 是 Linux 内核中默认的调度器，它的目标是提供公平的 CPU 时间分配，以便于所有线程都能够获得合理的运行时间。CFS 主要特点包括：

- **红黑树数据结构**：CFS 使用红黑树来组织线程的调度队列，通过红黑树的平衡性质来实现公平调度。
- **虚拟运行时间**：CFS 通过维护每个线程的虚拟运行时间（Virtual Runtime）来决定线程的调度顺序。虚拟运行时间越小的线程优先级越高。
- **最小化任务运行时间**：CFS 会尽量将 CPU 时间均匀分配给所有线程，使得每个线程的运行时间都接近理想值，以达到公平性和响应性。

### 2. 实时调度器（Real-time Scheduler）：

实时调度器是针对实时任务的调度器，它主要包括 FIFO（First-In-First-Out）调度器和 RR（Round Robin）调度器两种。实时调度器的特点包括：

- **优先级调度**：实时调度器根据线程的优先级来决定调度顺序，优先级高的线程优先级更高，能够抢占优先级低的线程。
- **硬实时和软实时**：实时调度器可以分为硬实时和软实时两种，硬实时保证任务在规定的时间内完成，软实时允许一定程度的延迟。

### 3. 调度策略选择：

在 Linux 中，可以通过设置不同的调度策略和优先级来控制线程的调度行为。常见的调度策略包括：

- **SCHED_OTHER**：默认的调度策略，适用于普通的时间共享任务。
- **SCHED_FIFO**：FIFO 调度策略，适用于实时任务，具有最高的优先级。
- **SCHED_RR**：RR 调度策略，适用于实时任务，具有次高的优先级。

### 4. 调度算法实现：

Linux 调度器的实现是在内核中进行的，通过调度器模块和调度算法来管理线程的调度和执行。调度算法主要包括进程调度算法和线程调度算法，通过时间片、优先级和调度队列等数据结构来实现线程的调度和切换。

总的来说，Linux 线程调度算法是由内核的调度器负责实现的，主要包括完全公平调度器（CFS）和实时调度器（Real-time Scheduler）。不同的调度器和调度策略适用于不同的场景，可以根据实际需求进行选择和配置。

## linux 协程是怎么调度的

在 Linux 中，协程的调度是由用户态的协程库负责实现的，而不是由内核调度器进行管理。因此，协程的调度是基于用户态的调度器实现的，通常使用协作式调度（Cooperative Scheduling）来控制协程的执行顺序。

### 1. 协程的特点：

- **用户态实现**：协程是在用户态下实现的，不依赖于内核的调度器，具有较低的开销和更高的灵活性。
- **非抢占式调度**：协程的调度是通过协作的方式实现的，不会被强制中断，而是由程序员显式地控制协程的暂停和恢复。

### 2. 协程调度器：

协程调度器是一个用户态的调度器，负责管理和调度协程的执行。协程调度器通常包含以下几个关键组件：

- **调度队列**：用于存放待执行的协程，并根据调度策略决定执行顺序。
- **调度算法**：根据不同的调度策略来决定协程的执行顺序，如先进先出、优先级等。
- **调度器接口**：提供了控制协程执行的接口，包括启动、暂停、恢复和销毁等操作。

### 3. 协程的调度过程：

协程的调度过程主要包括以下几个步骤：

1. **启动协程**：将待执行的协程加入调度队列，并启动调度器开始执行协程。
2. **协程执行**：调度器从调度队列中选择一个协程进行执行，执行一段时间后暂停。
3. **协程切换**：当协程暂停时，调度器将控制权交给其他协程，选择下一个待执行的协程进行调度。
4. **恢复执行**：当其他协程执行完毕或主动让出CPU时，调度器将再次选择当前协程并恢复其执行。

### 4. 协程调度器的实现：

协程调度器的实现可以基于事件循环（Event Loop）或协程池（Coroutine Pool）等技术，通过事件驱动或协程轮询来实现协程的调度和执行。常见的协程库包括 Boost.Coroutine、libco 和 Coroutine in C++ 等。

总的来说，Linux 中的协程调度是由用户态的协程库负责实现的，通过协程调度器来管理和调度协程的执行。协程调度器采用协作式调度方式，根据调度策略选择下一个待执行的协程，并在协程执行一段时间后切换到其他协程，从而实现协程之间的协同执行。

## 消息队列 详解

消息队列是一种常见的通信模式，用于在不同组件或系统之间传递消息。它是一种基于先进先出（FIFO）原则的数据结构，消息发送者将消息放入队列的尾部，消息接收者从队列的头部获取消息。消息队列通常由消息中间件（Message Broker）来实现，它提供了消息存储、传输和路由等功能，以实现可靠的消息传递和异步通信。

下面详细解释消息队列的一些重要概念和特点：

### 1. 消息队列的组成部分：

- **消息**：要传递的数据单元，通常以文本或二进制格式表示，可以是任意类型的数据。
- **生产者（Producer）**：负责生成并发送消息到消息队列中的实体，将消息推送到队列中。
- **消费者（Consumer）**：负责从消息队列中获取并处理消息的实体，从队列中拉取消息进行处理。
- **消息队列**：用于存储消息的中间件，负责维护消息的顺序和状态，并确保消息的可靠传递。

### 2. 消息队列的特点：

- **解耦**：消息队列可以将生产者和消费者解耦，使它们不需要直接通信，降低了系统组件之间的耦合度。
- **异步**：消息队列实现了生产者和消费者之间的异步通信，生产者可以继续生产消息而不需要等待消费者处理完毕。
- **缓冲**：消息队列可以作为一个缓冲区，临时存储消息以应对生产者和消费者之间的速度差异。
- **扩展性**：消息队列可以水平扩展，通过增加更多的队列实例来处理更多的消息流量。
- **持久化**：一些消息队列支持消息的持久化，即使在系统重启后也不会丢失消息。

### 3. 消息队列的应用场景：

- **异步任务处理**：将耗时的任务放入消息队列，由消费者异步处理，提高系统的响应速度和并发能力。
- **解耦系统组件**：将不同系统组件之间的通信通过消息队列进行解耦，降低系统的耦合度和维护成本。
- **削峰填谷**：通过消息队列对请求进行排队和调度，平滑系统的请求流量，防止系统过载。
- **日志和监控**：将系统产生的日志和监控数据通过消息队列发送到中央化的日志分析和监控系统中进行分析和处理。
- **分布式系统集成**：在分布式系统中使用消息队列进行节点间通信和数据同步，实现分布式系统的集成和协同工作。

总的来说，消息队列是一种强大而灵活的通信模式，用于实现系统之间的异步通信、解耦系统组件、缓冲和削峰填谷等功能。通过合理地使用消息队列，可以提高系统的可靠性、扩展性和可维护性，是现代分布式系统中不可或缺的重要组件之一。

## 单线程和多线程的优势和劣势

单线程和多线程是两种不同的并发编程模型，它们各有优势和劣势，适用于不同的应用场景。

### 单线程的优势和劣势：

**优势：**

1. **简单易用**：单线程编程模型相对简单，不需要考虑线程同步、锁机制等复杂的并发控制问题。
2. **资源消耗低**：单线程只需要一个线程和一个执行栈，资源消耗较少，适用于资源受限的环境。
3. **可靠性高**：由于不存在多线程之间的竞态条件和锁问题，单线程程序更加稳定可靠，易于调试和维护。

**劣势：**

1. **性能受限**：单线程模型无法充分利用多核处理器的并行性能，无法同时处理多个任务，性能较低。
2. **响应速度慢**：单线程模型无法同时处理多个任务，可能导致某些任务等待时间较长，响应速度慢。
3. **阻塞问题**：单线程模型中如果遇到阻塞操作（如IO操作），会导致整个程序阻塞，影响其他任务的执行。

### 多线程的优势和劣势：

**优势：**

1. **并行处理**：多线程模型可以同时处理多个任务，充分利用多核处理器的并行性能，提高了程序的整体性能。
2. **提高响应速度**：多线程模型可以并发处理多个任务，提高了系统的响应速度和吞吐量。
3. **支持阻塞IO**：多线程模型可以使用阻塞IO，遇到阻塞操作时不会影响其他线程的执行。

**劣势：**

1. **复杂性增加**：多线程编程涉及到线程同步、锁机制等复杂的并发控制问题，增加了程序的复杂性和难度。
2. **资源消耗增加**：多线程模型需要创建和管理多个线程，会消耗更多的系统资源，如内存、CPU等。
3. **竞态条件和锁问题**：多线程模型容易出现竞态条件和锁问题，需要谨慎设计和管理锁机制，否则会导致死锁、饥饿等问题。

### 应用场景：

- **单线程**适用于简单的任务、资源受限的环境、IO密集型应用等。
- **多线程**适用于多核处理器、需要提高性能和响应速度的应用、CPU密集型应用等。

综上所述，单线程和多线程各有优劣，需要根据具体的应用场景和性能需求来选择适合的并发编程模型。

## fork()会发生什么，子进程会拷贝父进程那些数据

`fork()` 是一个创建新进程的系统调用，在调用 `fork()` 时，操作系统会创建一个新的子进程，这个子进程几乎是父进程的完整拷贝，包括代码段、数据段、堆栈等。下面是 `fork()` 的一般行为：

1. **父进程和子进程：** `fork()` 调用成功后，会在当前进程（父进程）中创建一个新的子进程，这两个进程在调用 `fork()` 之后会几乎完全一样，包括代码、数据和程序的执行状态。

2. **父子进程的返回值：** `fork()` 在父进程中返回子进程的 PID（进程ID），在子进程中返回 0。这样可以通过返回值的不同来区分父子进程。

3. **数据拷贝：** 在调用 `fork()` 时，操作系统会复制父进程的地址空间，包括代码段、数据段、堆和栈等。但是，操作系统使用了写时复制（Copy-On-Write，COW）技术，即只有在需要修改数据时才会进行实际的复制，这样可以尽量减少内存的消耗。

4. **文件描述符：** 子进程会继承父进程的文件描述符，包括标准输入、标准输出和标准错误等。

5. **其他资源：** 子进程会继承父进程的其他资源，如文件描述符、信号处理器等。

需要注意的是，尽管子进程是父进程的副本，但父子进程之间是独立运行的，它们各自拥有自己的地址空间，对自己地址空间的修改不会影响对方。在实际编程中，可以利用这个特性实现一些功能，比如使用 `fork()` 创建子进程来并行处理任务。

## bfork() 详解

`bfork()` 并不是标准的系统调用，而是某些特定操作系统或特定环境下的非标准扩展或自定义函数。因此，其行为和用法可能会因操作系统或环境的不同而有所不同。

在一些操作系统或环境中，`bfork()` 可能是一个自定义的函数，其功能类似于标准的 `fork()` 系统调用，用于创建一个新的子进程。但是，由于它不是标准的系统调用，因此具体的行为可能会有所不同，可能会有额外的参数或功能，或者在特定环境中实现了一些特殊的功能。

如果你具体指的是某个特定操作系统或环境下的 `bfork()` 函数，建议查阅相关文档或资料以获取详细的信息和用法说明。
